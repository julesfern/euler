#!/usr/bin/env ruby

# The sequence of triangle numbers is generated by adding the natural numbers. So the 
# 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:
# 
# 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
# 
# Let us list the factors of the first seven triangle numbers:
# 
#  1: 1
#  3: 1,3
#  6: 1,2,3,6
# 10: 1,2,5,10
# 15: 1,3,5,15
# 21: 1,3,7,21
# 28: 1,2,4,7,14,28
# We can see that 28 is the first triangle number to have over five divisors.
# 
# What is the value of the first triangle number to have over five hundred divisors?

# ----------------------------------------------------------------------------------
# Thinking out loud: This looks suspiciously like it's an inverted sieving problem made
# interesting by the indefinite length of the array and the triangle number requirement.
#
# This has to be about prime factors. For prime calculation i'm going to stick with the
# avoid-ruby-1.9's-prime-enumerator approach as it seems unsportsmanlike. So we'll
# implement a sieve and generate a set of primes with some conservative upper limit,
# so that we don't have to regenerate the prime list for each candidate triangle term.
#
# Since we only have to check primes up to the square root of the solution, i'll go with
# 100,000 as a finger-in-the-air upper limit for the primes required.
# 
# I had to go off and learn about prime factors to do this. For any number, let's say, 20:
# 
# 20 = 2*2*5
#
# All the non-prime factors may be found through all the unique combinations of the set of
# prime factors:
#
# 20 = 2*(2*5) = (2*2)*5 = (2*2*5)
#
# The factors of 20 are 1 (axiomatic), 2 (prime), 4, 5 (prime), 10, and 20 (axiomatic)
#
# For a larger number:
#
# 100 = (2*2*5*5) = (2*2)*(5*5) = 2*(2*5*5) = 2*(2*5)*5 = (2*2*5)*5
#
# The divisors of 100 are 1 (ax), 2 (pr), 4, 5 (pr), 10, 20, 25, 50, 100 (ax)
# for 9 total divisors.
#
# So - we're interested in the total combination space of the prime factors.
# Each prime factor we find multiplies the number of factors found thus far -
# finding 2^4 throws 5 options into the combination space including 2^0==1.
#
# ...
# in execution this will multiply the factor count by n+1 where n is the highest exponent
# of the current prime factor. 
#
# (Note: plaintext comments are becoming a pain. Consider MathML, OpenOffice Math, LaTeX or similar.)

def primes_upto(lim)
	primes = [2]
	sieve = [0,1]*(lim/2)
	n = 3
	while n<lim do
	  if sieve[n] == 1
	    # Check
	    j = n**2 # Only need to start checking at the square of your current candidate. This knocks about 0.5s off the runtime.
	    while j<lim do
	      sieve[j] = 0
	      j+=n
	    end
	    # Append
	    primes << n
	  end
	  n+=2 # Don't check even numbers, silly
	end
	return primes
end

min_divisors = 500 # Problem definition
primes = primes_upto(100_000)
i = 1 # current triangle term
t_solved = 0 # Solution

while t_solved==0 do
	t = (i*(i+1))/2
	f_count = 1 # Factor count including 1

	#  We'll start experimenting with primes as factors of
	# an ever-reducing remainder of t.
	remainder = t
	primes.each do |prime|
		break if prime**2 > t # Establish loop limit
		next if remainder%prime!=0

		exp = 1
		while remainder%prime == 0 do
			remainder = remainder/prime
			exp+=1
		end
		f_count *= exp
		#puts "#{t} has #{f_count} due to #{prime} with #{exp} possible exponents"

		break if remainder <= 1
	end

	t_solved = t if f_count > min_divisors
	i+=1
end

puts "t_solved: #{t_solved}"